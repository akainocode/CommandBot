###
dados - Dice rolling library

The string is the api!

Order of operations:<br>
<li> Parenthesis
<li> 'd' (left applicative)
<li> Multiplication/Division
<li> Addition/Subtraction

API:
d
roll
isValid
setSeed

@author Havvy
###

util = require 'util'
Random = require 'hrandom'
random = new Random()
innerParenthesis = /(\([^\(\)]*\))/
invalidChars = /[^0-9d\*\/\+\-\(\)]+/
diceRollExpression = /\d+d\d+/
addsub = /\d+[\+\-]\d*/
multdiv = /\d+[\*\/]\d+/

###
Source: http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
###
isNumeric = (n) ->
  not isNaN(parseFloat(n)) and isFinite n

balancedParenthesis = (string) ->
  open = 0
  for char in string
    switch char
      when "("
        open++
      when ")"
        open--
        if open < 0 then return false
  open is 0

###
@public
@param {Number} seed Seed to set the random generator to.
###
setSeed = (seed) ->
  random = new Random(seed)
  null # Otherwise, leak Random.

###
@param {String} A string that dados might be able to evaluate.
@return whether or not dados can evaluate it or not.
###
isValid = (roll) ->
  if (roll.length is 0 || !/\d/.test(roll)) then return false  
  if (not balancedParenthesis(roll)) then return false
  if (/[d\+\-\*\/]{2}/.test(roll)) then return false
  true

# Need a better name. Recursively do this replacement.
replaceWhilePossible = (string, regex, sub) ->
  matchExists = true
  while (matchExists)
    matchExists = false
    string = string.replace regex, (fragment) ->
      matchExists = true
      if typeof sub is "function" then sub(fragment) else sub
  
  string

###
Takes a string containing a binary operand, and evaluates it.
###
binaryExpression = (str, operand, evaluator) ->
  [a, b] = str.split operand
  [a, b] = [Number(a), Number(b)]
  evaluator a, b

d = (scale, magnitude) ->
  result = 0
  
  return NaN if (scale > 1000 || scale < 0 || magnitude < 0 || isNaN(scale))  
  return 0 if scale == 0 or magnitude == 0
  
  result += random.nextInt(magnitude) + 1 for [1..scale]
  result

multiply = (a, b) -> a * b
divide = (a, b) -> a / b
add = (a, b) -> a + b
subtract = (a, b) ->  if a? then a - b else -b

evaluate = (roll) ->
  # Evaluate subexpressions first.
  roll = replaceWhilePossible roll, innerParenthesis, (innerExpression) ->
    evaluate innerExpression[1..-2]

  # Evaluate the 'd' operator.
  roll = replaceWhilePossible roll, diceRollExpression, (fragment) -> 
    binaryExpression fragment, 'd', d
  
  # Evaluate multiplication and division.
  roll = replaceWhilePossible roll, multdiv, (fragment) ->
    if (fragment.indexOf('*') isnt -1)
      binaryExpression(fragment, '*', multiply)
    else
      binaryExpression(fragment, '/', divide)
  
  # Evaluate addition and subtraction.
  roll = replaceWhilePossible roll, addsub, (fragment) ->
    if (fragment.indexOf('+') isnt -1)
      binaryExpression(fragment, '+', add)
    else
      binaryExpression(fragment, '-', subtract)
  
  Number roll

###
@param {String} roll A possibly dirty roll.
@return 
###
roll = (req) ->
  req = replaceWhilePossible(req, "D", "d")
  req = replaceWhilePossible(req, invalidChars, "")
  roll = replaceWhilePossible(req, /d+$/, "");
  
  if not isValid roll then NaN else evaluate roll

module.exports = 
  d : d,
  roll : roll,
  isValid : isValid,
  setSeed : setSeed
