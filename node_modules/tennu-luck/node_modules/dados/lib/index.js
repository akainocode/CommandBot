// Generated by CoffeeScript 1.3.3

/*
dados - Dice rolling library

The string is the api!

Order of operations:<br>
<li> Parenthesis
<li> 'd' (left applicative)
<li> Multiplication/Division
<li> Addition/Subtraction

API:
d
roll
isValid
setSeed

@author Havvy
*/


(function() {
  var Random, add, addsub, balancedParenthesis, binaryExpression, d, diceRollExpression, divide, evaluate, innerParenthesis, invalidChars, isNumeric, isValid, multdiv, multiply, random, replaceWhilePossible, roll, setSeed, subtract, util;

  util = require('util');

  Random = require('hrandom');

  random = new Random();

  innerParenthesis = /(\([^\(\)]*\))/;

  invalidChars = /[^0-9d\*\/\+\-\(\)]+/;

  diceRollExpression = /\d+d\d+/;

  addsub = /\d+[\+\-]\d*/;

  multdiv = /\d+[\*\/]\d+/;

  /*
  Source: http://stackoverflow.com/questions/18082/validate-numbers-in-javascript-isnumeric
  */


  isNumeric = function(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  };

  balancedParenthesis = function(string) {
    var char, open, _i, _len;
    open = 0;
    for (_i = 0, _len = string.length; _i < _len; _i++) {
      char = string[_i];
      switch (char) {
        case "(":
          open++;
          break;
        case ")":
          open--;
          if (open < 0) {
            return false;
          }
      }
    }
    return open === 0;
  };

  /*
  @public
  @param {Number} seed Seed to set the random generator to.
  */


  setSeed = function(seed) {
    random = new Random(seed);
    return null;
  };

  /*
  @param {String} A string that dados might be able to evaluate.
  @return whether or not dados can evaluate it or not.
  */


  isValid = function(roll) {
    if (roll.length === 0 || !/\d/.test(roll)) {
      return false;
    }
    if (!balancedParenthesis(roll)) {
      return false;
    }
    if (/[d\+\-\*\/]{2}/.test(roll)) {
      return false;
    }
    return true;
  };

  replaceWhilePossible = function(string, regex, sub) {
    var matchExists;
    matchExists = true;
    while (matchExists) {
      matchExists = false;
      string = string.replace(regex, function(fragment) {
        matchExists = true;
        if (typeof sub === "function") {
          return sub(fragment);
        } else {
          return sub;
        }
      });
    }
    return string;
  };

  /*
  Takes a string containing a binary operand, and evaluates it.
  */


  binaryExpression = function(str, operand, evaluator) {
    var a, b, _ref, _ref1;
    _ref = str.split(operand), a = _ref[0], b = _ref[1];
    _ref1 = [Number(a), Number(b)], a = _ref1[0], b = _ref1[1];
    return evaluator(a, b);
  };

  d = function(scale, magnitude) {
    var result, _i;
    result = 0;
    if (scale > 1000 || scale < 0 || magnitude < 0 || isNaN(scale)) {
      return NaN;
    }
    if (scale === 0 || magnitude === 0) {
      return 0;
    }
    for (_i = 1; 1 <= scale ? _i <= scale : _i >= scale; 1 <= scale ? _i++ : _i--) {
      result += random.nextInt(magnitude) + 1;
    }
    return result;
  };

  multiply = function(a, b) {
    return a * b;
  };

  divide = function(a, b) {
    return a / b;
  };

  add = function(a, b) {
    return a + b;
  };

  subtract = function(a, b) {
    if (a != null) {
      return a - b;
    } else {
      return -b;
    }
  };

  evaluate = function(roll) {
    roll = replaceWhilePossible(roll, innerParenthesis, function(innerExpression) {
      return evaluate(innerExpression.slice(1, -1));
    });
    roll = replaceWhilePossible(roll, diceRollExpression, function(fragment) {
      return binaryExpression(fragment, 'd', d);
    });
    roll = replaceWhilePossible(roll, multdiv, function(fragment) {
      if (fragment.indexOf('*') !== -1) {
        return binaryExpression(fragment, '*', multiply);
      } else {
        return binaryExpression(fragment, '/', divide);
      }
    });
    roll = replaceWhilePossible(roll, addsub, function(fragment) {
      if (fragment.indexOf('+') !== -1) {
        return binaryExpression(fragment, '+', add);
      } else {
        return binaryExpression(fragment, '-', subtract);
      }
    });
    return Number(roll);
  };

  /*
  @param {String} roll A possibly dirty roll.
  @return
  */


  roll = function(req) {
    req = replaceWhilePossible(req, "D", "d");
    req = replaceWhilePossible(req, invalidChars, "");
    roll = replaceWhilePossible(req, /d+$/, "");
    if (!isValid(roll)) {
      return NaN;
    } else {
      return evaluate(roll);
    }
  };

  module.exports = {
    d: d,
    roll: roll,
    isValid: isValid,
    setSeed: setSeed
  };

}).call(this);
